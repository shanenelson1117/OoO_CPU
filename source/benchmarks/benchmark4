 // Torture test

// -------------------------------------------------
// 1. Basic init
// -------------------------------------------------
    addi x1, x0, 0x7FFFFFFF  // large positive (overflow test)
    addi x2, x0, -1          // negative immediate test
    addi x3, x0, 5
    addi x4, x0, 0

// -------------------------------------------------
// 2. WAW / WAR hazard chain
// -------------------------------------------------
    addi x5, x0, 1           // x5 = 1
    addi x5, x5, 2           // x5 = 3 (WAW hazard)
    add  x5, x5, x1          // x5 = 3 + 0x7FFFFFFF = 0x80000002 (WAR hazard check)

// -------------------------------------------------
// 3. Load-use hazard
// -------------------------------------------------
    sw   x3, 0(x0)           // mem[0] = 5
    lw   x6, 0(x0)           // x6 = 5
    add  x7, x6, x6          // x7 = 10

// -------------------------------------------------
// 4. Store-after-load and load-after-store hazards
// -------------------------------------------------
    lw   x8, 0(x0)           // x8 = 5
    addi x8, x8, 1           // x8 = 6
    sw   x8, 0(x0)           // mem[0] = 6
    lw   x9, 0(x0)           // x9 = 6

// -------------------------------------------------
// 5. Division edge cases
// -------------------------------------------------
    addi x10, x0, 10         // x10 = 10
    addi x11, x0, 3          // x11 = 3
    div  x12, x10, x11       // x12 = 3
    remu x13, x10, x11       // x13 = 1
    addi x14, x0, 0          // x14 = 0
    div  x15, x10, x14       // div by zero → -1 per RISC-V spec
    remu x16, x10, x14       // rem by zero → x10 (10)

// -------------------------------------------------
// 6. MULH sign edge cases
// -------------------------------------------------
    mulh x17, x1, x2         // high bits of (0x7FFFFFFF * -1) = 0xFFFFFFFF
    mulh x18, x2, x2         // high bits of (-1 * -1) = 0

// -------------------------------------------------
// 7. Branch predictor stress
// -------------------------------------------------
    addi x19, x0, 0
loop_branch_test:
    addi x19, x19, 1
    blt  x19, x3, loop_branch_test   // runs until x19 == 5
    beq  x3, x3, skip_unreachable    // taken
    addi x20, x0, 123                // skipped
skip_unreachable:

// -------------------------------------------------
// 8. Back-to-back taken branches
// -------------------------------------------------
    beq  x3, x3, bb1
    addi x21, x0, 111                // skipped
bb1:
    bne  x3, x4, bb2
    addi x21, x0, 222                // skipped
bb2:

// -------------------------------------------------
// 9. ROB wraparound stress (fill + flush)
// -------------------------------------------------
    addi x22, x0, 0
fill_loop:
    addi x22, x22, 1
    blt  x22, x1, fill_loop          // loops until x22 == 0x7FFFFFFF

// Force mispredict flush when ROB is busy
    beq  x0, x1, should_skip         // taken
    addi x23, x0, 42                 // skipped
should_skip:

// -------------------------------------------------
// 10. Long latency FU contention
// -------------------------------------------------
    mul  x24, x1, x3                 // x24 = 0x7FFFFFFF * 5
    mul  x25, x24, x3                 // x25 = x24 * 5
    div  x26, x25, x3                 // x26 = x25 / 5
    mul  x27, x26, x3                 // x27 = x26 * 5
    div  x28, x27, x3                 // x28 = x27 / 5

// -------------------------------------------------
// 11. Memory stress — sequential & repeated stores
// -------------------------------------------------
    addi x29, x0, 0                   // base address
    addi x30, x0, 40                  // 10 words
mem_init:
    sw   x0, 0(x29)                    // write 0
    addi x29, x29, 4
    bne  x29, x30, mem_init

// Write 1’s
    addi x29, x0, 0
mem_write_ones:
    addi x31, x0, 1
    sw   x31, 0(x29)
    addi x29, x29, 4
    bne  x29, x30, mem_write_ones

// -------------------------------------------------
// 12. HALT
// -------------------------------------------------
halt:
    jal  x0, halt
