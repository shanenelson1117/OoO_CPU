// Tests of the lui, logical, and shift instructions


//_start:
00000000111100000000001010010011 //0x0000: // addi x5, x0, 0x0F     // x5 = 0x0F
00000011001100000000001100010011 //0x0004: // addi x6, x0, 0x33     // x6 = 0x33
00001010101000000000001110010011 //0x0008: // addi x7, x0, 0xAA     // x7 = 0xAA
00000000010000000000001000010011 //0x000C: // addi x4, x0, 4        // x4 = 4, shift amount

00000000011000101111010000110011 //0x0010: // and x8, x5, x6        // x8 = x5 & x6 = 0x03
00000000011000101110010010110011 //0x0014: // or  x9, x5, x6        // x9 = x5 | x6 = 0x3F
00000000011000101100010100110011 //0x0018: // xor x10, x5, x6       // x10 = x5 ^ x6 = 0x3C

00000000010000111001010110110011 //0x001C: // sll x11, x7, x4       // x11 = x7 << 4 = 0xAA0
00000000010000111101011000110011 //0x0020: // srl x12, x7, x4       // x12 = x7 >> 4 logical = 0x0A
01000000010000111101011010110011 //0x0024: // sra x13, x7, x4       // x13 = x7 >> 4 arithmetic = 0x0A

00000000100101000000011100110011 //0x0028: // add x14, x8, x9       // x14 = 0x03 + 0x3F = 0x42
00000000101001110100011100110011 //0x002C: // xor x14, x14, x10     // x14 = 0x42 ^ 0x3C = 0x7E
00000000101101110110011100110011 //0x0030: // or  x14, x14, x11     // x14 = 0x7E | 0xAA0 = 0xAFE
00000000110001110100011100110011 //0x0034: // xor x14, x14, x12     // x14 = 0xAFE ^ 0x0A = 0xAF4
00000000110101110110011100110011 //0x0038: // or  x14, x14, x13     // x14 = 0xAF4 | 0xFA = 0xAFE

00000000000000000000000001101111 //0x003C: // j 0x003C             // infinite loop to end benchmark
