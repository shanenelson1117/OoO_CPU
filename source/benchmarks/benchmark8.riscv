         // STORE_VALS:
00000000101000000000111110010011    // ADDI x31, X0, 10
00000001111100000010000000100011   // Sw x31, 0(x0)   // Mem[0] = 10
00000000011100000000111110010011   // ADDI X31, x0, 7
00000001111100000010001000100011   // sw X31, 4(x0)   // Mem[8] = 7
00000000010000000000111110010011    // ADDI X31, x0, 4
00000001111100000010010000100011   // sw X31, 8(x0)  // Mem[16] = 4
00000000100100000000111110010011    // ADDI X31, x0, 9
00000001111100000010011000100011   // sw X31, 12(x0)  // Mem[24] = 9
00000000001100000000111110010011   // ADDI X31, x0, 3
00000001111100000010100000100011   // sw X31, 16(x0)  // Mem[32] = 3
00000000100000000000111110010011   // ADDI X31, x0, 8
00000001111100000010101000100011   // sw X31, 20(x0)  // Mem[40] = 8
00000000001000000000111110010011   // ADDI X31, x0, 2
00000001111100000010110000100011   // sw X31, 24(x0)  // Mem[48] = 2
00000000010100000000111110010011   // ADDI X31, x0, 5
00000001111100000010111000100011   // sw X31, 28(x0)  // Mem[56] = 5
00000000011000000000111110010011   // ADDI X31, x0, 6
00000011111100000010000000100011   // sw X31, 32(x0)  // Mem[64] = 6
00000000000100000000111110010011   // ADDI X31, x0, 1
00000011111100000010001000100011   // sw X31, 36(x0)  // Mem[72] = 1
   // MAIN:
00000000000100000000001010010011    // ADDI X5, x0, 1     // Need a constant 1 for decr
00000000100100000000111110010011    // ADDI X31, x0, 9     // for (X0 = 9; X0 > 0; X0--) 
   // OUTER_LOOP:
00000000000000000000000010010011   // ADDI X1, x0, 0     // for (X1 = 0; X1 < X0; X1++) 
00000000000100001000001000110011  // ADD X4, X1, X1      // For addressing, X4=8*X1
   // INNER_LOOP:
00000000010000100010000110000011   // lw X3, 4(X4)    // get A[X1+1]
00000000000000100010000100000011   // lw X2, 0(X4)    // get A[X1]  
00000000000000000000000000010011    // ADDI x0, x0, 0    // NOOP             
00000000000000000000000000010011   // addi x0, x0, 0     // Test X2 vs. X3
00000000001100010100100001100011     // blt x2, x3, 16        // Don't swap if X2 < X3
00000000000000000000000000010011     // ADDI x0, x0, 0    // NOOP
00000000001000100010001000100011   // sw X2, 4(X4)    // swap A[X1]
00000000001100100010000000100011  // sw X3, 0(X4)    // swap A[X1-1]
   // NO_SWAP:
00000000000100001000000010010011    // ADDI X1, X1, 1      // X1++
00000000010000100000001000010011   // ADDI X4, X4, 4      // Keep X4=8*X1
00000000000000000000000000010011   // nop     // Is X1 < X0?
11111101111100001100101011100011     // blt x1, x31, -44       // If so, continue inner loop
00000000000000000000000000010011    // ADDI x0, x0, 0    // NOOP
   // DONE_INNER:
01000000010111111000111110110011   // SUB X31, X31, X5      // X0--
00000000000011111000100001100011     // beq x31, x0, 16   // End outer loop when done
00000000000000000000000000010011    // ADDI x0, x0, 0    // NOOP
11111011100111111111000001101111     // jal x0, -72       // Continue outer loop
00000000000000000000000000010011    // ADDI x0, x0, 0    // NOOP
   // DONE_OUTER:
00000000000000000010010110000011   // lw X11, 0(x0)  // Read back values to regs X11-X20
00000000010000000010011000000011  // lw X12, 4(x0)
00000000100000000010011010000011  // lw X13, 8(x0)
00000000110000000010011100000011   // lw X14, 12(x0)
00000001000000000010011110000011   // lw X15, 16(x0)
00000001010000000010100000000011  // lw X16, 20(x0)
00000001100000000010100010000011   // lw X17, 24(x0)
00000001110000000010100100000011   // lw X18, 28(x0)
00000010000000000010100110000011   // lw X19, 32(x0)
00000010010000000010101000000011   // lw X20, 36(x0)
   // HALT:
00000000000000000000000001101111      // jal x0, 0              // HALT
