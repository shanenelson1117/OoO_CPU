    // Needs ~500 cycles

    // Initialize constants
    00000000101000000000000010010011 // ADDI x1, x0, 10    0   # x1 = 10
    00000000001100000000000100010011 // ADDI x2, x0, 3      4  # x2 = 3
    11111111101100000000000110010011 // ADDI x3, x0, -5      8 # x3 = -5 (simulate signed via immediate encoding if supported)
    00000000000100000000001000010011 // ADDI x4, x0, 1        12# x4 = 1

    // # Simple branch not taken
    00000000001000001000010001100011 //    BEQ x1, x2, skip1 16
    00000110010000000000001010010011 //    ADDI x5, x0, 100   20   # should execute
    // skip1:

    //  # Branch taken
    00000000001000001001010001100011 //    BNE x1, x2, skip2 24
    00001100100000000000001100010011 //    ADDI x6, x0, 200  28    # should NOT execute
    //skip2:

    // # Arithmetic chain
    00000000001000001000001110110011 //    ADD x7, x1, x2      32  # x7 = 13
    01000000001000111000010000110011 //    SUB x8, x7, x2      36  # x8 = 10

    //  # Multiply and high bits
    00000010001000001000010010110011 //    MUL x9, x1, x2      40  # x9 = 30
    00000010001100001001010100110011 //    MULH x10, x1, x3    44  # x10 = high bits of 10 * -5

    // # Signed division and remainder
    00000010001000001100010110110011 //    DIV x11, x1, x2     48  # x11 = 3
    00000010001000001111011000110011 //    REMU x12, x1, x2    52  # x12 = 1

    // # Store and Load
    00000000101100000010000000100011 //    SW x11, 0(x0)       56  # mem[0] = 3
    00000000000000000010011010000011 //   LW x13, 0(x0)        60 # x13 = 3

    // # Nested branching
    // branch1:
    00000000000100011100010001100011 //    BLT x3, x1, branch1_taken 64  # -5 < 10 -> taken
    00111110011100000000011100010011 //    ADDI x14, x0, 999        68   # skipped if branch taken
    // branch1_taken:

    //   # Jump over a block
    00000000110000000000000001101111 //    JAL x0, after_block 72
    00000000000100000000011110010011 //   ADDI x15, x0, 1   76  # skipped
    00000000000100000000100000010011 //   ADDI x16, x0, 666   80  # skipped
    // after_block:

    //   # More arithmetic
    00000000110001011000100010110011 //    ADD x17, x11, x12  84   # x17 = 4
    01000000001010001000100100110011 //    SUB x18, x17, x2   88   # x18 = 1
    00000010001110010000100110110011 //    MUL x19, x18, x3   92   # x19 = 1 * -5

    //  # More memory
    00000001001100000010001000100011 //    SW x19, 4(x0)     96    # mem[4] = -5
    00000000010000000010101000000011 //    LW x20, 4(x0)    100     # x20 = -5

    //  # Complex branch not taken
    00000000100101101000010001100011 //    BEQ x13, x9, no_jump  104  # 3 != 30, not equal -> continue
    00000000000100000000101010010011 //    ADDI x21, x0, 1       108
    // no_jump:

    //  # Loop-like structure
    00000000000000000000101100010011 //    ADDI x22, x0, 0   112    # x22 = i = 0
    //loop:
    00000000001010110000101100110011 //    ADD x22, x22, x2   116   # x22 += 3
    11111110000110110100111011100011 //    BLT x22, x1, loop    120  # while x22 < 10

    //  # After loop
    //after_loop:
    00000000000110110000101110110011 //    ADD x23, x22, x1  124   # x23 = final result
    00000000000000000000110001101111 //    JAL x24, 0 HALT  128
    00000000000000000000000000010011 // nop

