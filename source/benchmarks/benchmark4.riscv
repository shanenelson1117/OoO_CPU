 // High stress/corner case test. Needs ~8000 cycles.

// -------------------------------------------------
// 1. Basic init
// -------------------------------------------------
    01111111111100000000000010010011 // 0 addi x1, x0, 0x7FF   large positive (overflow test)
    11111111111100000000000100010011 // 4 addi x2, x0, -1          negative immediate test
    00000000010100000000000110010011 // 8 addi x3, x0, 5
    00000000000000000000001000010011 // 12 addi x4, x0, 0

// -------------------------------------------------
// 2. WAW / WAR hazard chain
// -------------------------------------------------
    00000000000100000000001010010011 // 16 addi x5, x0, 1           x5 = 1
    00000000001000101000001010010011 // 20 addi x5, x5, 2           x5 = 3 (WAW hazard)
    01000000001000101000001010110011 // 24 sub  x5, x5, x2          x5 = 3 - -1 = 4 (WAR hazard check), sub negative

// -------------------------------------------------
// 3. Load-use hazard
// -------------------------------------------------
    00000000001100000010000000100011 // 28 sw   x3, 0(x0)            mem[0] = 5
    00000000000000000010001100000011 // 32 lw   x6, 0(x0)            x6 = 5
    00000000011000110000001110110011 // 36 add  x7, x6, x6           x7 = 10

// -------------------------------------------------
// 4. Store-after-load and load-after-store hazards
// -------------------------------------------------
    00000000000000000010010000000011 // 40 lw   x8, 0(x0)            x8 = 5
    00000000000101000000010000010011 // 44 addi x8, x8, 1            x8 = 6
    00000000100000000010001000100011 // 48 sw   x8, 4(x0)            mem[4] = 6
    00000000010000000010010010000011 // 52 lw   x9, 4(x0)            x9 = 6

// -------------------------------------------------
// 5. Division edge cases
// -------------------------------------------------
    00000000101000000000010100010011 // 56 addi x10, x0, 10          x10 = 10
    00000000001100000000010110010011 // 60 addi x11, x0, 3           x11 = 3
    00000010101101010100011000110011 // 64 div  x12, x10, x11        x12 = 3
    00000010101101010111011010110011 // 68 remu x13, x10, x11        x13 = 1
    00000010110001101100011100110011 // 72 div x14, x13, x12         x14 = 0

// -------------------------------------------------
// 6. MULH sign edge cases
// -------------------------------------------------
    00000010001001010001100010110011 // 76 mulh x17, x10, x2         high bits of (10 * -1) = 0xFFFFFFFF
    00000010001000010001100100110011 // 80 mulh x18, x2, x2          high bits of (-1 * -1) = 0

// -------------------------------------------------
// 7. Branch predictor stress
// -------------------------------------------------
    00000000000000000000100110010011 // 84 addi x19, x0, 0
// loop_branch_test:
    00000000000110011000100110010011 // 88 addi x19, x19, 1
    11111110001110011100111011100011 // 92 blt  x19, x3, loop_branch_test   runs until x19 == 5
    00000000001100011000010001100011 // 96 beq  x3, x3, skip_unreachable     taken
    00000111101100000000101000010011 // 100 addi x20, x0, 123                skipped x20 = 0
// skip_unreachable:

// -------------------------------------------------
// 8. Back-to-back taken branches
// -------------------------------------------------
    00000000001100011000010001100011 // 104 beq  x3, x3, bb1
    00000110111100000000101010010011 // 108 addi x21, x0, 111                skipped
// bb1:
    00000000010000011001010001100011 // 112 bne  x3, x4, bb2
    00001101111000000000101010010011 // 116 addi x21, x0, 222               skipped
// bb2:

// -------------------------------------------------
// 9. ROB wraparound stress (fill + flush)
// -------------------------------------------------
    00000000000000000000101100010011 // 120 addi x22, x0, 0
// fill_loop:
    00000000000110110000101100010011 // 124 addi x22, x22, 1
    11111110000110110100111011100011 // 128 blt  x22, x1, fill_loop          loops until x22 == 0x7FF

// Force mispredict flush when ROB is busy
    00000000000100000000010001100011 // 132 beq  x0, x1, should_skip         taken
    00000010101000000000101110010011 // 136 addi x23, x0, 42                not skipped
// should_skip:

// -------------------------------------------------
// 10. Long latency FU contention
// -------------------------------------------------
    00000010001100110000110000110011 // 140 mul  x24, x6, x3                 x24 = 5 * 5
    00000010001111000000110010110011 // 144 mul  x25, x24, x3               x25 = 25 * 5
    00000010001111001100110100110011 // 148 div  x26, x25, x3                x26 = 125 / 5
    00000010001111010000110110110011 // 152 mul  x27, x26, x3                x27 = 25 * 5
    00000010001111011100111000110011 // 156 div  x28, x27, x3               x28 = 125 / 5

// -------------------------------------------------
// 11. Memory stress — sequential & repeated stores
// -------------------------------------------------
    00000000000000000000111010010011 // 160 addi x29, x0, 0                   base address
    00000010100000000000111100010011 // 164 addi x30, x0, 40                 10 words
// mem_init:
    00000000000011101010000000100011 // 168 sw   x0, 0(x29)                     write 0
    00000000010011101000111010010011 // 172 addi x29, x29, 4
    11111111111011101001110011100011 // 176 bne  x29, x30, mem_init

// Write 1’s
    00000000000000000000111010010011 // 180 addi x29, x0, 0
// mem_write_ones:
    00000000000100000000111110010011 // 184 addi x31, x0, 1
    00000001111111101010000000100011 // 188 sw   x31, 0(x29)
    00000000010011101000111010010011 // 192 addi x29, x29, 4
    11111111111011101001101011100011 // 196 bne  x29, x30, mem_write_ones

// -------------------------------------------------
// 12. HALT
// -------------------------------------------------
// halt:
    00000000000000000000000001101111 // 200 jal  x0, halt
